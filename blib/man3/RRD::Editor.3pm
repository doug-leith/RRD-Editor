.\" Automatically generated by Pod::Man 2.12 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RRD::Editor 3"
.TH RRD::Editor 3 "2011-05-17" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RRD::Editor \- Standalone tool (no need for RRDs.pm) to create and edit RRD files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use strict;
\& use RRD::Editor ();
\& 
\& # Create a new object
\& my $rrd = RRD::Editor\->new();
\&  
\& # Create a new RRD with 3 data sources called bytesIn, bytesOut and 
\& # faultsPerSec and one RRA which stores 1 day worth of data at 5 minute 
\& # intervals (288 data points). The argument format is the same as that used 
\& # by 'rrdtool create', see L<http://oss.oetiker.ch/rrdtool/doc/rrdcreate.en.html>
\& $rrd\->create("DS:bytesIn:GAUGE:600:U:U DS:bytesOut:GAUGE:600:U:U DS:faultsPerSec:COUNTER:600:U:U RRA:AVERAGE:0.5:1:288")
\&
\& # Save RRD to a file
\& $rrd\->save("myfile.rrd");
\& # The file format to use can also be optionally specified:
\& # $rrd\->save("myfile.rrd","native\-double");   # default; non\-portable format used by RRDTOOL
\& # $rrd\->save("myfile.rrd","portable\-double"); # portable, data stored in double\-precision
\& # $rrd\->save("myfile.rrd","portable\-single"); # portable, data stored in single\-precision
\&
\& # Load RRD from a file.  Automagically figures out the file format 
\& # (native\-double, portable\-double etc) 
\& $rrd\->open("myfile.rrd");
\& 
\& # Add new data to the RRD for the same 3 data sources bytesIn, 
\& # bytesOut and faultsPerSec.  The argument format is the same as that used by 
\& # 'rrdtool update', see L<http://oss.oetiker.ch/rrdtool/doc/rrdupdate.en.html>
\& $rrd\->update("N:10039:389:0.4");
\&  
\& # Show information about an RRD.  Output generated is similar to 
\& # "rrdtool info".
\& print $rrd\->info();
\& 
\& # XML dump of RRD contents.  Output generated is similar to "rrdtool dump".
\& print $rrd\->dump();
\& 
\& # Extract data measurements stored in RRAs of type "AVERAGE"
\& # The argument format is the same as that used by 'rrdtool fetch' and 
\& # the output generated is also similar, see
\& # L<http://oss.oetiker.ch/rrdtool/doc/rrdfetch.en.html>
\& print $rrd\->fetch("AVERAGE");
\& 
\& # Get the time when the RRD was last updated (as a unix timestamp)
\& printf "RRD last updated at %d\en", $rrd\->last();
\&
\& # Get the measurements added when the RRD was last updated
\& print $rrd\->lastupdate();
\& 
\& # Get the min step size (or resolution) of the RRD.  This defaults to 300s unless specified
\& otherwise when creating an RRD.
\& print $rrd\->minstep()
.Ve
.Sh "Edit DSs"
.IX Subsection "Edit DSs"
.Vb 2
\& # Add a new data\-source called bytes.  Argument format is the same as $rrd\->create().
\& $rrd\->add_DS("DS:bytes:GAUGE:600:U:U");
\& 
\& # Delete the data\-source bytesIn
\& $rrd\->delete_DS("bytesIn");
\& 
\& # Get a list of the data\-sources names
\& print $rrd\->DS_names();
\& 
\& # Change the name of data\-source bytes to be bytes_new
\& $rrd\->rename_DS("bytes", "bytes_new")
\& 
\& # Get the heartbeat value for data\-source bytesOut (the max number of seconds that
\& # may elapse between data measurements)
\& printf "Heartbeat for DS bytesOut = %d\en", $rrd\->DS_heartbeat("bytesOut");
\&
\& # Set the heartbeat value for data\-source bytesOut to be 1200 secs
\& $rrd\->set_DS_heartbeat("bytesOut",1200);
\& 
\& # Get the type of data\-source bytesOut
\& printf "Type of DS bytesOut = %s\en", $rrd\->DS_type("bytesOut");
\& 
\& # Set the type of data\-source bytesOut to be COUNTER
\& $rrd\->set_DS_type("bytesOut", "COUNTER");
\& 
\& # Get the minimum value allowed for measurements from data\-source bytesOut
\& printf "Min value of DS bytesOut = %s\en", $rrd\->DS_min("bytesOut");
\&
\& # Set the minimum value allowed for measurements from data\-source bytesOut to be 0
\& $rrd\->set_DS_min("bytesOut",0);
\& 
\& # Get the maximum value allowed for measurements from data\-source bytesOut
\& printf "Max value of DS bytesOut = %s\en", $rrd\->DS_max("bytesOut");
\& 
\& # Set the maximum value allowed for measurements from data\-source bytesOut to be 100
\& $rrd\->set_DS_max("bytesOut",100);
.Ve
.Sh "Edit RRAs"
.IX Subsection "Edit RRAs"
.Vb 3
\& # Add a new RRA which stores 1 weeks worth of data at 30 minute intervals 
\& # (336 data points)
\& $rrd\->add_RRA("RRA:AVERAGE:0.5:6:336");
\&
\& # RRAs are identified by an index in range 0 .. $rrd\->num_RRAs().  The index 
\& # of an RRD can also be 
\& # found using $rrd\->info() or $rrd\->dump()
\& 
\& # Delete an existing RRA with index $rra_idx.  
\& my $rra_idx=1; 
\& $rrd\->delete_RRA($rra_idx);
\& 
\& # Get the number of rows/data points stored in an RRD
\& my $rra_idx=0; 
\& printf "number of rows of RRA %d = %d\en", $rra_idx, $rrd\->RRA_numrows($rra_idx);
\& 
\& # Change the number of rows/data points stored in the RRA with index 
\& # $rra_idx to 600.
\& $rra\->resize_RRA($rra_idx, 600);
\& 
\&  # Get the value of bytesIn stored at the 10th row/data\-point in the 
\& # RRA with index $rra_idx.
\& printf "Value of data\-source bytesIn at row 10 in RRA %d = %d", $rra_idx, $rra\->RRA_el($rra_idx, "bytesIn", 10);
\& 
\&  # Set the value of bytesIn at the 10th row/data\-point to be 100
\& $rra\->set_RRA_el($rra_idx, "bytesIn", 10, 100);  
\& 
\& # Get the xff value for the RRA with index $rra_idx
\& printf "Xff value of RRA %d = %d\en", $rra_idx, $rra\->RRA_xff($rra_idx);
\&
\& # Set the xff value to 0.75 for the RRA with index $rra_idx
\& $rra\->RRA_xff($rra_idx,0.75);
\& 
\& # Get the type (AVERAGE, LAST etc) of the RRA with index $rra_idx
\& print $rrd\->RRA_type($rra_idx);
\& 
\& # Get the step (in seconds) of the RRA with index $rra_idx
\& print $rrd\->RRA_step($rra_idx);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
RRD:Editor implements most of the functionality of \s-1RRDTOOL\s0, apart from graphing, plus adds some new editing and portability features.  It aims to be portable and self-contained (no need for RRDs.pm).
.PP
RRD::Editor provides the ability to add/delete DSs and RRAs and to get/set most of the parameters in DSs and RRAs (renaming, resizing etc). It also allows the data values stored in each \s-1RRA\s0 to be inspected and changed individually.  That is, it provides almost complete control over the contents of an \s-1RRD\s0.
.PP
The \s-1RRD\s0 files created by \s-1RRDTOOL\s0 use a binary format (let's call it \f(CW\*(C`native\-double\*(C'\fR) that is not portable across platforms.  In addition to this file format, RRD:Editor provides two new portable file formats (\f(CW\*(C`portable\-double\*(C'\fR and \f(CW\*(C`portable\-single\*(C'\fR) that allow the exchange of files.  RRD::Editor can freely convert \s-1RRD\s0 files between these three formats (\f(CW\*(C`native\-double\*(C'\fR,\f(CW\*(C`portable\-double\*(C'\fR and \f(CW\*(C`portable\-single\*(C'\fR).
.PP
Notes:
.IP "\(bu" 4
times must all be specified as unix timestamps (i.e. \-1d, \-1w etc don't work, and there is no @ option in rrdupdate).
.IP "\(bu" 4
there is full support for \s-1COUNTER\s0, \s-1GAUGE\s0, \s-1DERIVE\s0 and \s-1ABSOLUTE\s0 data-source types but the \s-1COMPUTE\s0 type is only partially supported.
.IP "\(bu" 4
there is full support for \s-1AVERAGE\s0, \s-1MIN\s0, \s-1MAX\s0, \s-1LAST\s0 \s-1RRA\s0 types but the \s-1HWPREDCT\s0, \s-1MHWPREDICT\s0, \s-1SEASONAL\s0 etc types are only partially supported).
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
.Vb 1
\& my $rrd=new RRD:Editor\->new();
.Ve
.PP
Creates a new RRD::Editor object
.Sh "create"
.IX Subsection "create"
.Vb 1
\& $rrd\->create($args);
.Ve
.PP
The method will create a new \s-1RRD\s0 with the data-sources and RRAs specified by \f(CW$args\fR.   \f(CW$args\fR is a string that contains the same sort of command line arguments that would be passed to \f(CW\*(C`rrdtool create\*(C'\fR.   The format for  \f(CW$args\fR is:
.PP
[\-\-start|\-b start time] [\-\-step|\-s step] [\-\-format|\-f encoding] [DS:ds\-name:DST:heartbeat:min:max] [RRA:CF:xff:steps:rows]
.PP
where \s-1DST\s0 may be one of \s-1GAUGE\s0, \s-1COUNTER\s0, \s-1DERIVE\s0, \s-1ABSOLUTE\s0 and \s-1CF\s0 may be one of \s-1AVERAGE\s0, \s-1MIN\s0, \s-1MAX\s0, \s-1LAST\s0.  Possible values for encoding are \f(CW\*(C`native\-double\*(C'\fR, \f(CW\*(C`portable\-double\*(C'\fR, \f(CW\*(C`portable\-single\*(C'\fR.  If omitted, defaults to \f(CW\*(C`native\-double\*(C'\fR (the non-portable file format used by \s-1RRDTOOL\s0). See <http://oss.oetiker.ch/rrdtool/doc/rrdcreate.en.html> for further information.
.Sh "open"
.IX Subsection "open"
.Vb 1
\& $rrd\->open($file_name);
.Ve
.PP
Load the \s-1RRD\s0 in the file called \f(CW$file_name\fR.  Only the file header is loaded initially, to improve efficiency, with the body of the file subsequently loaded if needed.  The file format (\f(CW\*(C`native\-double\*(C'\fR, \f(CW\*(C`portable\-double\*(C'\fR etc) is detected automagically.
.Sh "save"
.IX Subsection "save"
.Vb 3
\& $rrd\->save();
\& $rrd\->save($file_name);
\& $rrd\->save($file_name, $encoding);
.Ve
.PP
Save \s-1RRD\s0 to a file called \f(CW$file_name\fR with format specified by \f(CW$encoding\fR.  Possible values for \f(CW$encoding\fR are \f(CW"native\-double"\fR, \f(CW"portable\-double"\fR, \f(CW"portable\-single"\fR.
.PP
If omitted, \f(CW$encoding\fR defaults to the format of the file specified when calling \f(CW\*(C`open()\*(C'\fR, or to \f(CW\*(C`native\-double\*(C'\fR if the \s-1RRD\s0 has just been created using \f(CW\*(C`create()\*(C'\fR.  \f(CW\*(C`native\-double\*(C'\fR is the non-portable binary format used by \s-1RRDTOOL\s0.  \f(CW\*(C`portable\-double\*(C'\fR is portable across platforms and stores data as double-precision values. \f(CW\*(C`portable\-single\*(C'\fR is portable across platforms and stores data as single-precision values (reducing the \s-1RRD\s0 file size by approximately half).  If interested in the gory details, \f(CW\*(C`portable\-double\*(C'\fR is just the native-double format used by Intel 32\-bit platforms (i.e. little-endian byte ordering, 32 bit integers, 64 bit \s-1IEEE\s0 754 doubles, storage aligned to 32 bit boundaries) \- an arbitrary choice, but not unreasonable since Intel platforms are probably the most widespread at the moment, and compatible with web tools such as javascriptRRD <http://javascriptrrd.sourceforge.net/>.
.PP
If the \s-1RRD\s0 was opened using \f(CW\*(C`open()\*(C'\fR, then \f(CW$file_name\fR is optional and if omitted \f(CW\*(C`$rrd\-\*(C'\fR\fIsave()\fR> will save the \s-1RRD\s0 to the same file as it was read from.
.Sh "close"
.IX Subsection "close"
.Vb 1
\& $rrd\->close();
.Ve
.PP
Close an \s-1RRD\s0 file accessed using \f(CW\*(C`open()\*(C'\fR or \f(CW\*(C`save()\*(C'\fR.  Calling \f(CW\*(C`close()\*(C'\fR flushes any cached data to disk.
.Sh "info"
.IX Subsection "info"
.Vb 1
\& my $info = $rrd\->info();
.Ve
.PP
Returns a string containing information on the DSs and RRAs in the \s-1RRD\s0 (but not showing the data values stored in the RRAs).  Also shows details of the file format (\f(CW\*(C`native\-double\*(C'\fR, \f(CW\*(C`portable\-double\*(C'\fR etc) if the \s-1RRD\s0 was read from a file.
.Sh "dump"
.IX Subsection "dump"
.Vb 2
\& my $dump = $rrd\->dump();
\& my $dump = $rrd\->dump($arg);
.Ve
.PP
Returns a string containing the complete contents of the \s-1RRD\s0 (including data) in \s-1XML\s0 format.  \f(CW$arg\fR is optional. Possible values are \*(L"\-\-no\-header\*(R" or \*(L"\-n\*(R", which remove the \s-1XML\s0 header from the output string.
.Sh "fetch"
.IX Subsection "fetch"
.Vb 1
\& my $vals = $rrd\->fetch($args);
.Ve
.PP
Returns a string containing a table of measurement data from the \s-1RRD\s0.  \f(CW$arg\fRs is a string that contains the same sort of command line arguments that would be passed to \f(CW\*(C`rrdtool fetch\*(C'\fR.   The format for \f(CW$args\fR is:
.PP
.Vb 1
\& CF [\-\-resolution|\-r resolution] [\-\-start|\-s start] [\-\-end|\-e end]
.Ve
.PP
where \f(CW\*(C`CF\*(C'\fR may be one of \s-1AVERAGE\s0, \s-1MIN\s0, \s-1MAX\s0, \s-1LAST\s0.  See <http://oss.oetiker.ch/rrdtool/doc/rrdfetch.en.html> for further details.
.Sh "update"
.IX Subsection "update"
.Vb 1
\& $rrd\->update($args);
.Ve
.PP
Feeds new data values into the \s-1RRD\s0.   \f(CW$args\fR is a string that contains the same sort of command line arguments that would be passed to \f(CW\*(C`rrdtool update\*(C'\fR.   The format for \f(CW$args\fR is:
.PP
.Vb 1
\& [\-\-template:\-t ds\-name[:ds\-name]...] N|timestamp:value[:value...] [timestamp:value[:value...] ...]
.Ve
.PP
See <http://oss.oetiker.ch/rrdtool/doc/rrdupdate.en.html> for further details.
.PP
Since\f(CW\*(C`update()\*(C'\fR is often called repeatedly, for greater efficiency in-place updating of \s-1RRD\s0 files is used where possible.  To understand this, a little knowledge of the \s-1RRD\s0 file format is needed.  \s-1RRD\s0 files consist of a small header containing details of the DSs and \s-1RRA\s0, and a large body containing the data values stored in the RRAs.  Reading the body into memory is relatively costly since it is much larger than the header, and so is only done by RRD::Editor on an \*(L"as-needed\*(R" basis.  So long as the body has not yet been read into memory when \f(CW\*(C`update()\*(C'\fR is called, \f(CW\*(C`update()\*(C'\fR will update the file on disk i.e. without reading in the body.  In this case there is no need to call \f(CW\*(C`save()\*(C'\fR.   If the body has been loaded into memory when \f(CW\*(C`update()\*(C'\fR is  called, then the copy of the data stored in memory will be updated and the file on disk left untouched \- a call to \f(CW\*(C`save()\*(C'\fR is then needed to freshen the file stored on disk.  Seems complicated, but its actually ok in practice.  If all you want to do is efficiently update a file, just use the following formula:
.PP
.Vb 3
\& $rrd\->open($file_name);
\& $rrd\->update($args);
\& $rrd\->close();
.Ve
.PP
and that's it.  If you want to do more, then be sure to call \f(CW\*(C`save()\*(C'\fR when you're done.
.Sh "last"
.IX Subsection "last"
.Vb 1
\& my $unixtime = $rrd\->last();
.Ve
.PP
Returns the time when the data stored in the \s-1RRD\s0 was last updated.  The time is returned as a unix timestamp.  This value should not be confused with the last modified time of the \s-1RRD\s0 file.
.Sh "set_last"
.IX Subsection "set_last"
.Vb 1
\& $rrd\->set_last($unixtime);
.Ve
.PP
Set the last update time to equal \f(CW$unixtime\fR.  \s-1WARNING:\s0 Rarely needed, use with caution !
.Sh "lastupdate"
.IX Subsection "lastupdate"
.Vb 1
\& my @vals=$rrd\->lastupdate();
.Ve
.PP
Return a list containing the data-source values inserted at the most recent update to the \s-1RRD\s0
.Sh "minstep"
.IX Subsection "minstep"
.Vb 1
\& my $minstep = $rrd\->minstep();
.Ve
.PP
Returns the minimum step size (in seconds) used to store data values in the \s-1RRD\s0.  \s-1RRA\s0 data intervals must be integer multiples of this step size.  The min step size defaults to 300s when creating an \s-1RRD\s0 (where it is referred to as the \*(L"resolution\*(R").   \s-1NB:\s0 Changing the min step size is hard as it would require resampling all of the stored data, so we leave this \*(L"to do\*(R".
.Sh "add_DS"
.IX Subsection "add_DS"
.Vb 1
\& $rrd\->add_DS($arg);
.Ve
.PP
Add a new data-source to the \s-1RRD\s0.  Only one data-source can be added at a time. Details of the data-source to be added are specified by the string \f(CW$arg\fR. The format of \f(CW$arg\fR is:
.PP
.Vb 1
\& [DS:ds\-name:DST:heartbeat:min:max]
.Ve
.PP
where \s-1DST\s0 may be one of \s-1GAUGE\s0, \s-1COUNTER\s0, \s-1DERIVE\s0, \s-1ABSOLUTE\s0 i.e. the same format as used for \f(CW$rrd\fR\->\fIcreate()\fR.
.Sh "delete_DS"
.IX Subsection "delete_DS"
.Vb 1
\& $rrd\->delete_DS($ds\-name);
.Ve
.PP
Delete the data-source with name \f(CW$ds\fR\-name from the \s-1RRD\s0.   \s-1WARNING:\s0 This will irreversibly delete all of the data stored for the data-source.
.Sh "DS_names"
.IX Subsection "DS_names"
.Vb 1
\& my @ds\-names = $rrd\->DS_names();
.Ve
.PP
Returns a list containing the names of the data-sources in the \s-1RRD\s0.
.Sh "rename_DS"
.IX Subsection "rename_DS"
.Vb 1
\& $rrd\->rename_DS($ds\-name, $ds\-newname);
.Ve
.PP
Change the name of data-source \f(CW\*(C`$ds\-name\*(C'\fR to be \f(CW\*(C`$ds\-newname\*(C'\fR
.Sh "DS_heartbeat"
.IX Subsection "DS_heartbeat"
.Vb 1
\& my $hb= $rrd\->DS_heartbeat($ds\-name);
.Ve
.PP
Returns the current heartbeat (in secodns) of a data-source.  The heartbeat is the max number of seconds that may elapse between data measurements before declaring that data is missing.
.Sh "set_DS_heartbeat"
.IX Subsection "set_DS_heartbeat"
.Vb 1
\& $rrd\->set_DS_heartbeat($ds\-name,$hb);
.Ve
.PP
Sets the heartbeat value (in seconds) of data-source \f(CW\*(C`$ds\-name\*(C'\fR to be \f(CW$hb\fR.
.Sh "DS_type"
.IX Subsection "DS_type"
.Vb 1
\& my $type = $rrd\->DS_type($ds\-name);
.Ve
.PP
Returns the type (\s-1GAUGE\s0, \s-1COUNTER\s0 etc) of a data-source.
.Sh "set_DS_type"
.IX Subsection "set_DS_type"
.Vb 1
\& $rrd\->set_DS_type($ds\-name, $type);
.Ve
.PP
Sets the type of data-source \f(CW\*(C`$ds\-name\*(C'\fR to be \f(CW$type\fR.
.Sh "DS_min"
.IX Subsection "DS_min"
.Vb 1
\& my $min = $rrd\->DS_min($ds\-name);
.Ve
.PP
Returns the minimum allowed for measurements from data-source \f(CW\*(C`$ds\-name\*(C'\fR.  Measurements below this value are set equal to \f(CW$min\fR when stored in the \s-1RRD\s0.
.Sh "set_DS_min"
.IX Subsection "set_DS_min"
.Vb 1
\& $rrd\->set_DS_min($ds\-name, $min);
.Ve
.PP
Set the minimum value for data-source \f(CW$ds\fR\-name to be \f(CW$min\fR.
.Sh "DS_max"
.IX Subsection "DS_max"
.Vb 1
\& my $max = $rrd\->DS_max($ds\-name);
.Ve
.PP
Returns the maximum allowed for measurements from data-source \f(CW$ds\fR\-name.  Measurements above this value are set equal to \f(CW$max\fR when stored in the \s-1RRD\s0.
.Sh "set_DS_max"
.IX Subsection "set_DS_max"
.Vb 1
\& $rrd\->set_DS_max($ds\-name, $max);
.Ve
.PP
Set the maximum value for data-source \f(CW$ds\fR\-name to be \f(CW$max\fR.
.Sh "add_RRA"
.IX Subsection "add_RRA"
.Vb 1
\& $rrd\->add_RRA($arg);
.Ve
.PP
Add a new \s-1RRA\s0 to the \s-1RRD\s0.   Only one \s-1RRA\s0 can be added at a time. Details of the \s-1RRA\s0 to be added are specified by the string \f(CW$arg\fR. The format of \f(CW$arg\fR is:
.PP
.Vb 1
\& [RRA:CF:xff:steps:rows]
.Ve
.PP
where \s-1CF\s0 may be one of \s-1AVERAGE\s0, \s-1MIN\s0, \s-1MAX\s0, \s-1LAST\s0 i.e. the same format as used for \f(CW$rrd\fR\->\fIcreate()\fR.
.Sh "num_RRAs"
.IX Subsection "num_RRAs"
.Vb 1
\& my $num_RRAs = $rrd\->num_RRAs();
.Ve
.PP
Returns the number of RRAs stored in the \s-1RRD\s0.   Unfortunaely, unlike data-sources, RRAs are not named and so are only identified by an index in the range 0 .. \f(CW\*(C`num_RRAs()\*(C'\fR.  The index of an \s-1RRD\s0 can be found using \f(CW\*(C`info()\*(C'\fR or \f(CW\*(C`dump()\*(C'\fR.
.Sh "delete_RRA"
.IX Subsection "delete_RRA"
.Vb 1
\& $rrd\->delete_RRA($rra_idx);
.Ve
.PP
Delete the \s-1RRA\s0 with index \f(CW$rra_idx\fR (see above discussion for how to determine the index of an \s-1RRA\s0). \s-1WARNING:\s0 This will irreversibly delete all of the data stored in the \s-1RRA\s0.
.Sh "RRA_numrows"
.IX Subsection "RRA_numrows"
.Vb 1
\& my $numrows = $rrd\->RRA_numrows($rra_idx);
.Ve
.PP
Returns the number of rows in the \s-1RRA\s0 with index \f(CW$rra_idx\fR.
.Sh "resize_RRA"
.IX Subsection "resize_RRA"
.Vb 1
\& $rra\->resize_RRA($rra_idx, $numrows);
.Ve
.PP
Change the number of rows to be \f(CW$numrows\fR in the \s-1RRA\s0 with index \f(CW$rra_idx\fR.   \s-1WARNING:\s0 If \f(CW$numrows\fR is smaller than the current row size, excess data points will be discarded.
.Sh "RRA_el"
.IX Subsection "RRA_el"
.Vb 1
\& my ($t,$val) = $rra\->RRA_el($rra_idx, $ds\-name, $row);
.Ve
.PP
Returns the timestamp and the value of data-source \f(CW$ds\fR\-name stored at row \f(CW$row\fR in the \s-1RRA\s0 with index \f(CW$rra_idx\fR.  \f(CW$row\fR must be in the range [0..\f(CW\*(C`RRA_numrows($rra_idx)\*(C'\fR\-1].  Row 0 corresponds to the oldest data point stored and row \f(CW\*(C`RRA_numrows($rra_idx)\*(C'\fR\-1 to the most recent data point.
.Sh "set_RRA_el"
.IX Subsection "set_RRA_el"
.Vb 1
\& $rra\->set_RRA_el($rra_idx, $ds\-name, $row, $val);
.Ve
.PP
Set the stored value equal to \f(CW$val\fR for data-source \f(CW$ds\fR\-name stored at row \f(CW$row\fR in the \s-1RRA\s0 with index \f(CW$rra_idx\fR.
.Sh "RRA_xff"
.IX Subsection "RRA_xff"
.Vb 1
\& my $xff = $rra\->RRA_xff($rra_idx);
.Ve
.PP
Returns the xff value for the \s-1RRA\s0 with index \f(CW$rra_idx\fR.  The xff value defines the proportion of an \s-1RRA\s0 data interval that may contain \s-1UNKNOWN\s0 data (i.e. missing data) and still be treated as known.  For example, an xff value 0.5 in an \s-1RRA\s0 with data interval 300 seconds (5 minutes) means that if less than 150s of valid data is available since the last measurement, \s-1UNKNOWN\s0 will be stored in the \s-1RRA\s0 for the next data point.
.Sh "set_RRA_xff"
.IX Subsection "set_RRA_xff"
.Vb 1
\& $rra\->RRA_xff($rra_idx,$xff);
.Ve
.PP
Sets the xff value to \f(CW$xff\fR for the \s-1RRA\s0 with index \f(CW$rra_idx\fR.
.Sh "RRA_step"
.IX Subsection "RRA_step"
.Vb 1
\& my $step = $rrd\->RRA_step($rra_idx);
.Ve
.PP
Returns the data interval (in seconds) of the \s-1RRA\s0 with index \f(CW$rra_idx\fR.    \s-1NB:\s0 Changing the step size is hard as it would require resampling the data stored in the \s-1RRA\s0, so we leave this \*(L"to do\*(R".
.Sh "RRA_type"
.IX Subsection "RRA_type"
.Vb 1
\& my $type = $rrd\->RRA_type($rra_idx);
.Ve
.PP
Returns the type of the \s-1RRA\s0 with index \f(CW$rra_idx\fR i.e. \s-1AVERAGE\s0, \s-1MAX\s0, \s-1MIN\s0, \s-1LAST\s0 etc.  \s-1NB:\s0 Changing the type of an \s-1RRA\s0 is hard (impossible ?) as the stored data doesn't contain enough information to allow its type to be changed.  To change type, its recommended instead to delete the \s-1RRA\s0 and add a new \s-1RRA\s0 with the desired type.
.SH "EXPORTS"
.IX Header "EXPORTS"
You can export the following functions if you do not want to use the object orientated interface:
.PP
.Vb 10
\& create
\& open
\& save
\& close
\& update
\& info
\& dump
\& fetch
\& last 
\& set_last
\& lastupdate
\& minstep
\& add_RRA
\& delete_RRA
\& num_RRAs
\& RRA_numrows
\& resize_RRA
\& RRA_type
\& RRA_step
\& RRA_xff
\& set_RRA_xff
\& add_DS
\& delete_DS
\& DS_names
\& rename_DS
\& DS_heartbeat
\& set_DS_heartbeat
\& DS_min
\& set_DS_min
\& DS_max
\& set_DS_max
\& DS_type
\& set_DS_type
.Ve
.PP
The tag \f(CW\*(C`all\*(C'\fR is available to easily export everything:
.PP
.Vb 1
\& use RRD::Editor qw(:all);
.Ve
.SH "Portability/Compatibility with RRDTOOL"
.IX Header "Portability/Compatibility with RRDTOOL"
The RRD::Editor code is portable, and so long as you stick to using the portable-double and portable-single file formats the \s-1RRD\s0 files generated will also be portable.  Portability issues arise when the \f(CW\*(C`native\-double\*(C'\fR file format of RRD::Editor is used to store RRDs.  This format tries to be compatible with the non-portable binary format used by \s-1RRDTOOL\s0, which requires RRD::Editor to figure out nasty low-level details of the platform it is running on (byte ordering, byte alignment, representation used for doubles etc).   To date, RRD::Editor and \s-1RRDTOOL\s0 have been confirmed compatible (i.e. they can read each others \s-1RRD\s0 files) on the following platforms:
.PP
Intel 686 32bit, AMD64/Intel x86 64bit, \s-1ARM\s0 32bit (Versatile/PB, little-endian), \s-1MIPS\s0 32bit (Malta), PowerPC 32bit
.PP
If your platform is not listed, there is a good chance things will \*(L"just work\*(R" but double checking that \s-1RRDTOOL\s0 can read the \f(CW\*(C`native\-double\*(C'\fR format \s-1RRD\s0 files generated by RRD::Editor, and vice-versa, would be a good idea if that's important to you.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
RRD::Simple, RRDTool::OO, RRDs,
<http://www.rrdtool.org>, examples/*.pl,
.SH "VERSION"
.IX Header "VERSION"
Ver 0.01_4
.SH "AUTHOR"
.IX Header "AUTHOR"
Doug Leith
.PP
<http://www.leith.ie>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-rrd\-db at rt.cpan.org\*(C'\fR, or through the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=RRD\-Editor>.  I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2011 D.J.Leith.
.PP
This program is free software; you can redistribute it and/or modify it under the terms of either: the \s-1GNU\s0 General Public License as published by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
